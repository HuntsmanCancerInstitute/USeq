package edu.utah.seq.vcf.xml.caris;

import java.io.*;
import java.util.regex.*;
import edu.utah.seq.vcf.VCFParser;
import util.gen.*;
import java.util.*;

/**
 * Takes a patient vcf file parsed from a Caris json report and compares it to a vcf generated by reprocessing the raw data.
 * Writes out a final arbitrated vcf containing all the Caris calls plus non duplicate recall variants with no FILTER flags.
 * 
 * @author david.nix@hci.utah.edu 
 **/
public class CarisVcfComparator {

	//user defined fields
	private File carisVcf = null;
	private File recallVcf = null;
	private File mergedVcf = null;
	private SimpleVcf[] fVcfs;
	private SimpleVcf[] rVcfs;	
	private int bpPaddingForOverlap = 2;

	//counters
	private int numberCaris = 0;
	private int numberRecall = 0;
	private int numberExactMatches = 0;
	private int numberCarisWithOnlyOverlap = 0;
	private int numberModifiedCarisCalls = 0;
	private int numberCarisWithNoMatch = 0;
	private int numberPassingRecallWithNoMatch = 0;
	
	private ArrayList<SimpleVcf> vcfToPrint = new ArrayList<SimpleVcf>();
	private ArrayList<String> headerLines = new ArrayList<String>();
	
	
	

	//constructors
	public CarisVcfComparator(String[] args){
		try {
			long startTime = System.currentTimeMillis();
			processArgs(args);

			//load vcf files
			fVcfs = load(carisVcf, true);
			rVcfs = load(recallVcf, true);
			numberRecall = rVcfs.length;

			compareVcfs();

			processCarisVcfs();
			
			processRecallVcfs();
			
			printVcfs();
			
			printStats();

			//finish and calc run time
			double diffTime = ((double)(System.currentTimeMillis() -startTime))/60000;
			System.out.println("\nDone! "+Math.round(diffTime)+" Min\n");

		} catch (Exception e) {
			e.printStackTrace();
			Misc.printErrAndExit("\nProblem running CarisJson2Vcf app!");
		}
	}

	private void printStats() {
		System.out.println("\nComparator stats:");
		System.out.println( numberRecall +"\t# Recall variants");
		System.out.println( numberCaris +"\t# Caris variants");
		System.out.println( numberExactMatches +"\t# Exact match");
		System.out.println( numberCarisWithOnlyOverlap +"\t# Overlap recal variants");
		System.out.println( numberModifiedCarisCalls +"\t# Recommended for modification");
		System.out.println( numberCarisWithNoMatch +"\t# No match"); 
		System.out.println( numberPassingRecallWithNoMatch +"\t# Passing recall variants with no xml vcf match");
	}

	private void printVcfs() {
		//sort vcf
		SimpleVcf[] vcf = new SimpleVcf[vcfToPrint.size()];
		vcfToPrint.toArray(vcf);
		Arrays.sort(vcf);
		Pattern pat = Pattern.compile("N_DP=.+SOMATIC");
		
		try {
			Gzipper out = new Gzipper(mergedVcf);
			//fetch merged header
			String[] header = mergeHeaders(headerLines);
			
			for (String h: header) out.println(h);
			for (SimpleVcf v: vcf) {
				if (v.getFilter().toLowerCase().contains("fail") == false) {
					//fix the the SOMATIC info
					String line = v.getVcfLine();
					line = pat.matcher(line).replaceFirst("MIXED_SOMATIC_GERMLINE");
					out.println(line);
				}
			}
			
			out.close();
		} catch (IOException e) {
			e.printStackTrace();
			Misc.printErrAndExit("\nERROR: problem writing out the merged vcf file. "+mergedVcf);
		}
	}

	private void processRecallVcfs() {
		//for each Recall vcf, call this after processing the Caris vcfs, skip those with a fail filter field
		for (SimpleVcf r:rVcfs){
			//print it?
			if (r.isPrint() && r.getFilter().toLowerCase().contains("fail") == false) {
				vcfToPrint.add(r);
				if (r.getMatch() == null) numberPassingRecallWithNoMatch++;
			}
		}
	}
	
	/**Merges header lines eliminating duplicates.  Does a bad ID name collision checking, silently keeps first one. 
	 * Returns null if CHROM lines differ. */
	public static String[] mergeHeaders(ArrayList<String> header) {
		
		LinkedHashSet<String> other = new LinkedHashSet<String>();
		LinkedHashSet<String> contig = new LinkedHashSet<String>();
		LinkedHashSet<String> info = new LinkedHashSet<String>();
		LinkedHashSet<String> filter = new LinkedHashSet<String>();
		LinkedHashSet<String> format = new LinkedHashSet<String>();
		TreeSet<String> source = new TreeSet<String>();
		String chromLine = "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\tTUMOR";

		for (String h: header){
			h=h.trim();
			if (h.startsWith("##contig")){
				if (contig.contains(h) == false) contig.add(h);
			}
			
			//modify the caris DP info 
			else if (h.startsWith("##INFO=<ID=DP,Number=1,Type=Integer,Description=")){
				info.add("##INFO=<ID=DP,Number=1,Type=Integer,Description=\"Caris Total Tumor Depth\">");
			}
			
			//swap out the somatic info
			else if (h.startsWith("##INFO=<ID=SOMATIC,Number=0,Type=Flag,Description=")) {
				info.add("##INFO=<ID=MIXED_SOMATIC_GERMLINE,Number=0,Type=Flag,Description=\"Mutation is from a tumor only analysis thus somatic or germline.\">");
			}
			
			else if (h.startsWith("##INFO")){
				if (info.contains(h) == false) info.add(h);
			}
			else if (h.startsWith("##FILTER")){
				if (filter.contains(h) == false) filter.add(h);
			}
			else if (h.startsWith("##FORMAT")){
				if (format.contains(h) == false) format.add(h);
			}
			else if (h.startsWith("##source=")){
				source.add(h);
			}
			else if (h.startsWith("#CHROM")){
				//don't do anything, just skip it
			}
			else if (other.contains(h) == false) {
				other.add(h);
			}
		}


		//add in filter lines
		filter.add(SimpleVcf.ncFilter);

		//remove ID dups from contig, filter, format, info
		ArrayList<String> contigAL = VCFParser.mergeHeaderIds(contig);
		ArrayList<String> filterAL = VCFParser.mergeHeaderIds(filter);
		ArrayList<String> formatAL = VCFParser.mergeHeaderIds(format);
		ArrayList<String> infoAL = VCFParser.mergeHeaderIds(info);

		ArrayList<String> lines = new ArrayList<String>();
		for (String s : other) lines.add(s);
		for (String s : source) lines.add(s);
		for (String s : contigAL) lines.add(s);
		for (String s : filterAL) lines.add(s);
		for (String s : infoAL) lines.add(s);
		for (String s : formatAL) lines.add(s);
		if (chromLine != null) lines.add(chromLine);

		return Misc.stringArrayListToStringArray(lines);
	}

	private void processCarisVcfs() {
		//for each Caris record
		for (SimpleVcf f: fVcfs){
			numberCaris++;
			//exact match? 
			if (f.getMatch() != null) {
				numberExactMatches++;
				//exact match then add caris info to recall
				SimpleVcf vcf = f.getMatch();
				vcf.appendID(f);
				vcf.appendINFO(f);
				f.setPrint(false);
			}
			else {
				//So no exact match any overlap?
				if (f.getOverlap().size()!=0) numberCarisWithOnlyOverlap++;

				//No exact or overlap
				else {
					System.err.println("WARNING: No match to this Caris variant:");
					System.err.println("\t"+f.getVcfLine());
					numberCarisWithNoMatch++;
				}
				//always print it
				f.appendFilter("NC");
				vcfToPrint.add(f);
			}
		}
	}

	private void compareVcfs() {
		//slow comparator, could do many things to speed up...
		//for each Caris record
		for (int i=0; i< fVcfs.length; i++){
			SimpleVcf f = fVcfs[i];

			//for each Recal variant
			for (int j=0; j< rVcfs.length; j++){
				SimpleVcf r = rVcfs[j];
				if (f.compareToExact(r)){
					if (f.getMatch() !=null || r.getMatch() != null) System.err.println("WARNING: more than one exact match found for \n\t"+f+"\n\t"+r);
					f.setMatch(r);
					r.setMatch(f);
				}
				else if (f.compareToOverlap(r)){
					//IO.pl("Overlap xml "+f.getOriginalRecord());
					//IO.pl("Overlap rec "+r.getOriginalRecord());
					f.getOverlap().add(r);
					r.getOverlap().add(f);
				}
			}
		}
	}

	private SimpleVcf[] load(File vcf, boolean excludeContig) {
		String[] lines = IO.loadFileIntoStringArray(vcf);
		ArrayList<SimpleVcf> al = new ArrayList<SimpleVcf>();
		for (String v: lines){
			if (v.startsWith("#") == false) {
				al.add(new SimpleVcf(v, bpPaddingForOverlap));
			}
			else {
				if (excludeContig){
					if (v.startsWith("##contig") == false) headerLines.add(v);
				}
				else headerLines.add(v);
			}
		}
		SimpleVcf[] svs = new SimpleVcf[al.size()];
		al.toArray(svs);
		return svs;
	}

	public static void main(String[] args) {
		if (args.length ==0){
			printDocs();
			System.exit(0);
		}
		new CarisVcfComparator(args);
	}		

	/**This method will process each argument and assign new varibles*/
	public void processArgs(String[] args){
		Pattern pat = Pattern.compile("-[a-z]");
		String useqVersion = IO.fetchUSeqVersion();
		String source = useqVersion+" Args: "+ Misc.stringArrayToString(args, " ");
		System.out.println("\n"+ source +"\n");
		for (int i = 0; i<args.length; i++){
			String lcArg = args[i].toLowerCase();
			Matcher mat = pat.matcher(lcArg);
			if (mat.matches()){
				char test = args[i].charAt(1);
				try{
					switch (test){
					case 'c': carisVcf = new File(args[++i]); break;
					case 'r': recallVcf = new File(args[++i]); break;
					case 'm': mergedVcf = new File(args[++i]); break;
					default: Misc.printErrAndExit("\nProblem, unknown option! " + mat.group());
					}
				}
				catch (Exception e){
					Misc.printErrAndExit("\nSorry, something doesn't look right with this parameter: -"+test+"\n");
				}
			}
		}
		//check files
		if (carisVcf == null || carisVcf.exists()==false || recallVcf == null || recallVcf.exists()==false) Misc.printErrAndExit("\nError: cannot find both of your vcf files to compare?!\n");
		if (mergedVcf == null) Misc.printErrAndExit("\nError: please provide a named file for writing the merged vcf!\n");
		mergedVcf.getParentFile().mkdirs();
	}	

	public static void printDocs(){
		System.out.println("\n" +
				"**************************************************************************************\n" +
				"**                           Caris Vcf Comparator: March 2022                       **\n" +
				"**************************************************************************************\n" +
				"CVC compares a Caris vcf generated with the CarisXmlVcfParser to a recalled vcf.\n"+
				"Exact recall vars are so noted and removed. Caris vcf with no exact but one\n"+
				"overlapping record can be merged with -k. Be sure to vt normalize each before running.\n"+
				"Recall variants failing FILTER are not saved.\n"+

				"\nOptions:\n"+
				"-c Path to a the Caris xml parsed vcf file, see the CarisXmlVcfParser app.\n"+
				"-r Path to a recalled snv/indel vcf file.\n"+
				"-m Path to named vcf file for saving the results.\n"+

				"\nExample: java -Xmx2G -jar pathToUSeq/Apps/CarisVcfComparator -f TL-18-03CFD6.vcf\n" +
				"     -r /F1/TL-18-03CFD6_recall.vcf.gz -g -c -m /F1/TL-18-93CFD6_merged.vcf.gz -k \n\n" +

				"**************************************************************************************\n");
	}



}
